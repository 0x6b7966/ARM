#ARM64下的寄存器
- 通用寄存器（用来存放一般性的数据）
  - x0~x30 (64位)
  - x29 又名fp (用于保存栈底的地址)
  - x30 又名lr（bl跳转后就会把下一条指令地址写到lr中）
  - w0~w30 （32位）它些就是x0~x30的低32位
- 浮点寄存器（CPU中专门提供浮点数寄存器来处理浮点数）
  - D0~D31（64位）
  - S0~S31 （32位）这些就是D0~D31的低32位
- 向量寄存器 （现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.
  - V0-V31（128位）
- 状态寄存器（又称 CPSR【current program status register】寄存器） user模式下没有
  - CPSR寄存器是32位的，每一位的功能如下 31 30 29 28 27~8  7  6  5  4   3     2   1    0    N   Z   C  V  保留   I   F T M4 M3 M2 M1 M0
  - CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!
  - N【负数标志】、Z【0标志】、C【进位标志】、V【溢出标志】均为条件码标志位。
- 栈寄存器
  - SP （任意时刻会保存我们栈顶的地址）
  - FP （用于保存栈底的地址）
  
#ARM64下常用的汇编指令
```
这里我只是简单整理一下，后面再写一下代码案例来介绍
```
####基础指令
- MOV  - MOV X1，X0 ; 将寄存器X0的值传送到寄存器X1
- ADD - ADD X0，X1，X2 ; 寄存器X1和X2的值相加后传送到X0
- SUB - SUB X0，X1，X2 ; 寄存器X1和X2的值相减后传送到X0
- AND - AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0
- ORR - ORR X0，X0，#9 ; X0的值与9相或后的值传送到X0
- EOR - EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0
  
####堆栈操作
- STR  - 将数据从寄存器中读出来,存到内存中. STR - STR X0, [SP, #0x8] ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间
- STP - STR 的变种指令，可以同时操作两个寄存器 STP x29, x30, [sp, #0x10] ; 将x29,x30存入栈中
- LDR -  将数据从内存中读出来,存到寄存器中  LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5
- LDP -  LDR 的变种指令，可以同时操作两个寄存器 LDP x29, x30, [sp, #0x10] ; 将栈中的值取出存放到x29, x30
  
####跳转操作
- BL 将下一条指令的地址放入lr(x30)寄存器
- RET 默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!
- CMP  比较指令，相当于SUBS，影响程序状态寄存器
  - B.GT  比较结果是大于，执行标号，否则不跳转
  - B.GE  比较结果是大于等于，执行标号，否则不跳转
  - B.EQ  比较结果是等于，执行标号，否则不跳转
  - B.HI   比较结果是无符号大于，执行标号，否则不跳转
  - b.ne  比较结果是否 非0
- CBZ - CBZ ; 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）
- CBNZ - CBNZ ; 比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）
  
####ADRP  是计算指定的数据地址 到当前PC值的相对偏移（eg：adrp x0, 1）
1. 将1的值,左移12位 1 0000 0000 0000 == 0x1000
2. 将PC寄存器的低12位清零 0x1002e6874 ==> 0x1002e6000
3. 将1 和 2 的结果相加 给 X0 寄存器!

####ARM汇编算术操作


####ARM汇编内存操作
####单寄存器读写指令
- ldr（load registor）把内存地址加载到寄存器  按字长操作
  move x1, #0x12
  ldr  x0, [x1]
- str (store registor) 把寄存器的值写入到内存地址  按字长操作
  move x1, #0x0f
  str  x1, [x0, #oxoC]
- ldrb 按字节操作
  mov x1, #0x0f
  strb x1, [x0, #0x0c]
  ldrb x0, [x4, #0x2c]
- ldrh 半字操作
- strh 半字存储
- ldrbt user模式下
- strbt
- ldrt  不带b表示字节
- strt
- ldrsb
- ldrsh
####多寄存器的读写指令，操作一片连续内存
- ldm (load multiple) LDMIA(IA 地址模式)  R0!(基址寄存器 -> 指向存储器, !:意思是最后把值保存到r0){R1,R2,R3或者 R1-R3} 意思是把R0的值加载到这一推寄存器里
- 地址模式； A-after B-before
  - 数据块模式：IA(传输后地址加4个字节)； IB（付送前地址加4）；DA(传输后地址减4)； DB(传送前减4)
  - 堆栈模式：满底层堆栈
- STM (存储)
  move x1, #0x00
  stmia x1, {x2-x9}

####数据交换指令
- swp (swap) swp r0, r1, [r2] 内存和寄存器字交换 r0相当于一个中间值 
  mov r1, #0x0f
  mov r2, #0x12
  swp r1, r1, [r2]
- swpb 字节交换
  
####跳转指令，状态操作
在语言学习的时候，经常有函数调用，这个过程用指令来描述 就是跳转 
实际上我们的跳转就是通过往PC计数器传入相应的值，来告诉下一步应该去哪执行
如果没有跳转指令的话，每次在想要跳转的地方都要写
```
mov lr, pc
mov pc, x1
```
- B  （break 跳转）  跳转过去  语法 B 标签
  b sundy 
- BL  带返回的连接跳转
  bl sundy
  bl sundy 跳过去执行完了 再回来继续执行
- BX
- BLX 

####状态寄存器操作
- mrs （move to registor form status registor） 把程序状态寄存器的值传送到通用寄存器
  mrs x1, cpsr
- msr  (move to status registor form registor) 通用寄存器到程序状态寄存器
  msr cpsr, x2
  
####异常产生指令
- swi 软中断指令
- bkpt 断点中断指令
  
####伪指令
我们的指令已经可以做各类操作了，但我们操作起来太麻烦了。
比如我现在要设置一个值给寄存器R0，但下次我修改了寄存器R0后又需要读出来刚才的值，那我们就要先临时
保存值 到SPSR or CPSR,然后为断切换
再比如，我们要做一个循环，就要用label结合BL 不断进行，但如果我们要循环很多次。
我们就定义了一些类似于带参数的宏的操作一样，来定义我们的伪指令，方便我们更好的实现汇编程序逻辑。伪指令只是在汇编器之前作用，汇编之后会翻译为标准的汇编指令集。
又分为ARM汇编伪指令和GUN汇编伪指令。
- 常用伪指令
  - AREA 声明区域段，数据区，代码区等等
  - CODE16/CODE32  声明以下是32位还是16位。 
  - ENITY 用于指定程序的入口点。程序至少得有一个 就像C语言的 main函数。
  - END 用于通知编译器已经到了源程序的结尾
  - EQU 用于为程序中的常量 定义一个标识符  SUNDYCON1 EQU 0x32000000
  - EXPORT 导出标识，其他文件可以引用到
  - IMPORT 相当于静态引用
  - EXTERN 相当于动态引用
  - GET 相当于引用文件 GET "file.S"




#金句：放在最后
#函数的前4个参数存放到r0到r3中，其他参数存放到栈中；返回值放在r0中；