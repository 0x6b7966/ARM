#ARM64下的寄存器
- 通用寄存器（用来存放一般性的数据）
  - x0~x30 (64位)
  - x29 又名fp (用于保存栈底的地址)
  - x30 又名lr（bl跳转后就会把下一条指令地址写到lr中）
  - w0~w30 （32位）它些就是x0~x30的低32位
- 浮点寄存器（CPU中专门提供浮点数寄存器来处理浮点数）
  - D0~D31（64位）
  - S0~S31 （32位）这些就是D0~D31的低32位
- 向量寄存器 （现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.
  - V0-V31（128位）
- 状态寄存器（又称 CPSR【current program status register】寄存器） user模式下没有
  - CPSR寄存器是32位的，每一位的功能如下 31 30 29 28 27~8  7  6  5  4   3     2   1    0    N   Z   C  V  保留   I   F T M4 M3 M2 M1 M0
  - CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!
  - N【负数标志】、Z【0标志】、C【进位标志】、V【溢出标志】均为条件码标志位。
- 栈寄存器
  - SP （任意时刻会保存我们栈顶的地址）
  - FP （用于保存栈底的地址）
  
#ARM64下常用的汇编指令
```
这里我只是简单整理一下，后面再写一下代码案例来介绍
```
####基础指令
- MOV  - MOV X1，X0 ; 将寄存器X0的值传送到寄存器X1
- ADD - ADD X0，X1，X2 ; 寄存器X1和X2的值相加后传送到X0
- SUB - SUB X0，X1，X2 ; 寄存器X1和X2的值相减后传送到X0
- AND - AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0
- ORR - ORR X0，X0，#9 ; X0的值与9相或后的值传送到X0
- EOR - EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0
  
####堆栈操作
- STR  - 将数据从寄存器中读出来,存到内存中. STR - STR X0, [SP, #0x8] ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间
- STP - STR 的变种指令，可以同时操作两个寄存器 STP x29, x30, [sp, #0x10] ; 将x29,x30存入栈中
- LDR -  将数据从内存中读出来,存到寄存器中  LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5
- LDP -  LDR 的变种指令，可以同时操作两个寄存器 LDP x29, x30, [sp, #0x10] ; 将栈中的值取出存放到x29, x30
  
####跳转操作
- BL 将下一条指令的地址放入lr(x30)寄存器
- RET 默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!
- CMP  比较指令，相当于SUBS，影响程序状态寄存器
  - B.GT  比较结果是大于，执行标号，否则不跳转
  - B.GE  比较结果是大于等于，执行标号，否则不跳转
  - B.EQ  比较结果是等于，执行标号，否则不跳转
  - B.HI   比较结果是无符号大于，执行标号，否则不跳转
- CBZ - CBZ ; 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）
- CBNZ - CBNZ ; 比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）
  
####ADRP  是计算指定的数据地址 到当前PC值的相对偏移（eg：adrp x0, 1）
1. 将1的值,左移12位 1 0000 0000 0000 == 0x1000
2. 将PC寄存器的低12位清零 0x1002e6874 ==> 0x1002e6000
3. 将1 和 2 的结果相加 给 X0 寄存器!


#ARM汇编内存操作
#单寄存器读写指令
- ldr（load registor）把内存地址加载到寄存器  按字长操作
  move x1, #0x12
  ldr  x0, [x1]
- str (store registor) 把寄存器的值写入到内存地址  按字长操作
  move x1, #0x0f
  str  x1, [x0, #oxoC]
- ldrb 按字节操作
  mov x1, #0x0f
  strb x1, [x0, #0x0c]
  ldrb x0, [x4, #0x2c]
- ldrh 半字操作
- strh 半字存储
- ldrbt user模式下
- strbt
- ldrt  不带b表示字节
- strt
- ldrsb
- ldrsh
#多寄存器的读写指令，操作一片连续内存
- ldm (load multiple) LDMIA(IA 地址模式)  R0(基址寄存器 -> 指向存储器){R1,R2,R3或者 R1-R3} 意思是把R0的值加载到这一推寄存器里
- 地址模式； A-after B-before
  - 数据块模式：IA(传输后地址加4个字节)； IB（付送前地址加4）；DA(传输后地址减4)； 

  