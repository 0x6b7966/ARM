#从逆向分析入手
- 静态分析
  - 字符串加密
  - 类名，方法名混淆
    - 混淆前 [LZAlertView addText]
    - 混淆后 [m1m34355 addText]
  - 代码混淆 （加入没有意义的控制流程 ，打断程序代码片段。） 
- 调式 -> 反调试
- 注入 -> 反注入
- 中间人攻击
  - https 
  - 证书

#数据加密
- 字符串加密，把程序里的明文字符串进行加密
- 存储加密，存在本地的数据是一种加密的状态
- 网络加密，密文传输

#反调试，检测调试状态，拒绝调试器附加
- ptrace。让程序不能被调试器附加
  ```
  #import </usr/include/sys/ptrace.h>
  #import <dlfcn.h>

  int main(int argc, char * argv[]){
      <!-- ptrace(int _request, pid_t _pid, caddr_t _addr, int _data) -->
      //_request = 31时，是防止调试器附加
      //第一种方式
      ptrace(PT_DENY_ATTACH,0,0,0);

      //第二种 动态拿 ptrace符号
      //定义函数句柄
      void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);
      ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, "ptrace");
      ptrace_ptr(PT_DENY_ATTACH,0,0,0);
      
      syscall(26,31,0,0,0);
  }
  ```
- sysctl。通过一个指令，判断是否被附加
  ```
  #import <sys/sysctl.h>

  int myGetPid(){
      int err = 0;
      struct kinfo_proc* proc_list = NULL;
      size_t length = 0;
      
  }

  BOOL isDebuggerPresernt(){
      int name[4];

      struct kinfo_proc info;
      size_t info_size = sizeof(inof);

      info.kp_groc.p_flag = 0;

      name[0] = CTL_;
      name[1] = x;
      name[2] = x;
      name[3] = y;

      if(sysctl(name, 4, &info, &info_size, NULL, 0) == -1){
          NSLog(@"sysctl error...");
          return NO;
      }

      retrun ((info.kp_proc.p_flag $ O_TRACC0) != 0);
  }
  int main(int argc, char * argv[]){
      if(isDebuggerPresernt()){
          NSLog(@"sysctl success...");
      }
  }
  ```
- syscall。